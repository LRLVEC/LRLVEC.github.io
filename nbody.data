#version 460 core
in vec4 fragColor;
out vec4 color;
void main()
{
    color = fragColor;
}#include <metal_stdlib>
using namespace metal;

struct Particle
{
	float4 position;
	float4 velocity;
};

struct ParticleShared
{
    float3 position;
    float mass;
};

struct v2f
{
	float4 position [[position]]; 
	float3 color;
	float size [[point_size]];
};

v2f vertex vertexMain(uint vid [[vertex_id]],
	constant float4x4& trans [[buffer(0)]],
	device const Particle* particles [[buffer(1)]])
{
	v2f o;
	Particle particle = particles[vid];
	o.position = trans * float4(particles[vid].position.xyz, 1.0);
    float k = tanh(length(particles[vid].velocity.xyz) / 15);
	o.color = float3(1 - k, k, k);
	o.size = 2;
	return o;
}

half4 fragment fragmentMain(v2f in [[stage_in]])
{
	return half4(half3(in.color), half(1));
}

constant uint local_size_x = 256;

struct ParameterBuffer
{
    float dt;
    float G;
    uint num;
};

kernel void updatePos(
    device Particle* particles [[buffer(0)]],
    constant ParameterBuffer& params [[buffer(1)]],
    uint3 tid [[thread_position_in_grid]])
{
	if (tid.x < params.num)
		particles[tid.x].position.xyz += params.dt * particles[tid.x].velocity.xyz;
}

kernel void updateVel(
    device Particle* particles [[buffer(0)]],
    constant ParameterBuffer& params [[buffer(1)]],
    uint3 globalID [[thread_position_in_grid]],
    uint3 localID [[thread_position_in_threadgroup]])
{
    threadgroup ParticleShared sharedParticles[local_size_x];
    uint c0 = 0;
    float3 r = particles[globalID.x].position.xyz;
    float3 dv = float3(0);
    for (; c0 < params.num; c0 += local_size_x)
	{
        if ((c0 + localID.x) < params.num)
		{
            sharedParticles[localID.x].position = particles[c0 + localID.x].position.xyz;
            sharedParticles[localID.x].mass = particles[c0 + localID.x].position.w;
        }
        threadgroup_barrier(mem_flags::mem_threadgroup);
        
        for (int c1 = 0; c1 < 1024; c1++)
		{
            float3 dr = sharedParticles[c1].position - r;
            float drr = rsqrt(clamp(dot(dr, dr), 0.0001f, 10000000.0f));
            drr = drr * drr * drr;
            dv += (sharedParticles[c1].mass * drr) * dr;
        }
        threadgroup_barrier(mem_flags::mem_threadgroup);
    }
    particles[globalID.x].velocity.xyz += dv * params.G * params.dt;
}
#version 460 core
layout(std140, binding = 0) uniform transBuffer
{
    mat4 trans;
};
layout(location = 0) in vec3 position;
layout(location = 1) in vec3 velocity;
out vec4 fragColor;
void main()
{
    gl_Position = trans * vec4(position, 1);
    float k = tanh(length(velocity) / 15);
    fragColor = vec4(1 - k, k, k, 1);
}struct Parameter {
    dt: f32,
    G: f32,
    num: u32,
};

struct Particle {
    position: vec3f,
    mass: f32,
    velocity: vec3f,
};

struct ParticleShare {
    position: vec3f,
    mass: f32,
};

struct VertexOutput {
    @builtin(position) position: vec4f,
    @location(0) color: vec3f,
};

@group(0) @binding(0) var<uniform> params : Parameter;
@group(0) @binding(1) var<uniform> trans : mat4x4<f32>;
@group(0) @binding(2) var<storage, read> particles_read : array<Particle>;
@group(0) @binding(3) var<storage, read_write> particles : array<Particle>;

const block_thread_num : u32 = 256;
var<workgroup> particles_shared : array<ParticleShare, block_thread_num>;
@compute @workgroup_size(block_thread_num)
fn updateVel(
    @builtin(global_invocation_id) id: vec3<u32>,
    @builtin(local_invocation_id) tid: vec3<u32>
) {
    var r: vec3f;
    var dv: vec3f = vec3f(0);
    r = particles[id.x].position;
    for (var i: u32 = 0; i < params.num; i += block_thread_num) {
        particles_shared[tid.x].position = particles[i + tid.x].position;
        particles_shared[tid.x].mass = particles[i + tid.x].mass;
        workgroupBarrier();

        var c0: u32 = 0;
        for (; c0 < block_thread_num; c0++) {
            var dr: vec3f = particles_shared[c0].position - r;
            var drr: f32 = inverseSqrt(clamp(dot(dr, dr), 0.001, 10000000.0));
            drr = drr * drr * drr;
            dv += (particles_shared[c0].mass * drr) * dr;
        }
        workgroupBarrier();
    }
    particles[id.x].velocity += dv * params.G * params.dt;
}

@compute @workgroup_size(256)
fn updatePos(@builtin(global_invocation_id) id: vec3<u32>) {
    particles[id.x].position += params.dt * particles[id.x].velocity;
}

@vertex
fn vertexMain(@builtin(vertex_index) id: u32) -> VertexOutput {
    var out: VertexOutput;
    out.position = trans * vec4f(particles_read[id].position, 1);
    var k: f32 = tanh(length(particles_read[id].velocity) / 15);
    out.color = vec3f(1 - k, k, k);
    return out;
}

@fragment
fn fragmentMain(in: VertexOutput) -> @location(0) vec4f {
    //let linear_color = pow(in.color, vec3f(2.2));
    return vec4f(in.color, 1.0);
}
struct Particle
{
	vec3 position;
	float mass;
	vec3 velocity;
};

struct ParticleShared
{
	vec3 position;
	float mass;
};#version 460 core
#include "particle.h"

layout(local_size_x = 256)in;
layout(std430, binding = 0)buffer ParticlesBuffer
{
	Particle particles[];
};
layout(std140, binding = 1)uniform ParameterBuffer
{
	float dt;
	float G;
	uint num;
};
void main()
{
	particles[gl_GlobalInvocationID.x].position +=
		dt * particles[gl_GlobalInvocationID.x].velocity;
}
#version 460 core
#include "particle.h"

layout(local_size_x = 256)in;
layout(std430, binding = 0)buffer ParticlesBuffer
{
	Particle particles[];
};
layout(std140, binding = 1)uniform ParameterBuffer
{
	float dt;
	float G;
	uint num;
};

shared ParticleShared shared_particles[256];

void main()
{
	uint c0 = 0;
	vec3 r = particles[gl_GlobalInvocationID.x].position;
	vec3 dv = vec3(0);
	for (; c0 < num; c0 += 256)
	{
		shared_particles[gl_LocalInvocationID.x].position = particles[c0 + gl_LocalInvocationID.x].position;
		shared_particles[gl_LocalInvocationID.x].mass = particles[c0 + gl_LocalInvocationID.x].mass;
		barrier();
		for (int c1 = 0; c1 < 256; c1++)
		{
			vec3 dr = shared_particles[c1].position - r;
			float drr = inversesqrt(clamp(dot(dr, dr), 0.0001, 10000000.0));
			drr = drr * drr * drr;
			dv += (shared_particles[c1].mass * drr) * dr;
			// dv += (particles[c1].mass / (pow(dot(dr, dr), 1.5) + 0.00001)) * dr;
		}
		barrier();
	}
	particles[gl_GlobalInvocationID.x].velocity += dv * G * dt;
}